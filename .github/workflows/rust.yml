name: Rust

on:
  pull_request:
    branches:
      - 'develop'
      - 'main'

env:
  CARGO_TERM_COLOR: always
  cargo_env_version: cargo-env
  cargo_build_version: cargo-build
  GH_TOKEN: ${{ github.token }}

jobs:
  build:
    runs-on: ubuntu-latest
    steps:

      # Checkout the repo
      - uses: actions/checkout@v3

      # Restore rust env (i.e. ~/.rustup and ~/.cargo) from cache
      - name: Restore cached cargo-env
        id: restore-cache-cargo-env
        uses: actions/cache/restore@v3
        with:
          path: |
            /home/runner/.cargo
            /home/runner/.rustup
          key: ${{ runner.os }}-${{ runner.arch }}-${{ env.cargo_env_version }}

      # If cached version of rust env not found, build it from scratch
      - name: Setup rust environment
        if: steps.restore-cache-cargo-env.outputs.cache-hit != 'true'
        run: |
          echo remove previous rustup / cargo
          ls -la /home/runner
          rm -rf /home/runner/.rustup /home/runner/.cargo
          ls -la /home/runner

          echo install rustup
          curl -sSf https://sh.rustup.rs | sh -s -- -y
          source "$HOME/.cargo/env"
          ls -la ~
          
          echo install nightly
          rustup toolchain install --profile=minimal nightly
          rustup default nightly-x86_64-unknown-linux-gnu
          rustup toolchain remove stable
          rustup show
          # to compile the std lib we nee the src
          rustup component add rust-src --toolchain nightly
          
          echo install cargo-contract
          cargo install cargo-contract --version 2.0.0-rc

          echo install cargo-fmt
          rustup component add rustfmt

          echo set target platform
          rustup target add wasm32-unknown-unknown --toolchain nightly

      # Update rust and record output
      - name: Update rust
        id: update-rust
        run: |
          if rustup update | grep updated; then
            echo rust updated
            echo "updated=true" >> $GITHUB_OUTPUT
          else
            echo rust already up to date
            echo "updated=false" >> $GITHUB_OUTPUT
          fi

      # Check if rust is formatted correctly
      - name: Rust formatting check
        run: |
          cd contracts
          if cargo fmt --check; then
            echo "code formatted correctly"
          else
            echo "code formatted incorrectly"
            exit 1
          fi

      # Restore the cargo build from cache, if available
      - name: Restore cached cargo build
        id: restore-cache-cargo-build
        uses: actions/cache/restore@v3
        with:
          path: |
            contracts/target
          # the cached build is based on the OS, architecture, a tag and the hash of the config files for this build, i.e. the Cargo configuration. The cargo configs may differ across workflows, so the files have to be the same to reuse the cached build image across workflows
          key: ${{ runner.os }}-${{ runner.arch }}-${{ env.cargo_build_version }}-${{ hashFiles('**/Cargo.toml', '**/Cargo.lock') }}

      # Do the build
      - name: Build
        id: build
        run: |
          cd contracts
          cargo contract build --release

      # Do unit testing
      - name: Test
        run: |
          cd contracts
          RUST_BACKTRACE=1 cargo test --no-default-features --features std --release -- --nocapture
          exit $?

      # Save build + test files to cache, use for incremental builds in other runs to speed up future workflows with minor changes
      - name: Clear cargo build cache
        # always hit this job, irrelevant of errors above
        if: always() && (${{ steps.build.conclusion }} == "success" || ${{ steps.build.conclusion }} == "failure")
        continue-on-error: true
        run: |
          gh api \
            --method DELETE \
            -H "Accept: application/vnd.github+json" \
            /repos/${{ github.repository }}/actions/caches?key=${{ runner.os }}-${{ runner.arch }}-${{ env.cargo_build_version }}-${{ hashFiles('**/Cargo.toml', '**/Cargo.lock') }}

      - name: Save cargo build to cache
        uses: actions/cache/save@v3
        if: always() && (${{ steps.build.conclusion }} == "success" || ${{ steps.build.conclusion }} == "failure")
        with:
          path: |
            contracts/target
          key: ${{ runner.os }}-${{ runner.arch }}-${{ env.cargo_build_version }}-${{ hashFiles('**/Cargo.toml', '**/Cargo.lock') }}

    
      # If updated OR built from scratch, clear the cache and save a new cache copy
      - name: Clear cargo env cache
        if: always() && (steps.restore-cache-cargo-env.outputs.cache-hit != 'true' || steps.update-cargo.outputs.updated == 'true' || steps.update-rust.outputs.updated == 'true')
        continue-on-error: true
        run: |
          # cache can only be removed via an api call
          gh api \
            --method DELETE \
            -H "Accept: application/vnd.github+json" \
            /repos/${{ github.repository }}/actions/caches?key=${{ runner.os }}-${{ runner.arch }}-${{ env.cargo_env_version }}

      - name: Save cargo env to cache
        if: always() && (steps.restore-cache-cargo-env.outputs.cache-hit != 'true' || steps.update-cargo.outputs.updated == 'true' || steps.update-rust.outputs.updated == 'true')
        uses: actions/cache/save@v3
        with:
          path: |
            /home/runner/.cargo
            /home/runner/.rustup
          # the key is the OS name + architecture + tag, isolating each rust env to a specific OS. This cached copy can be used in any workflow using the same OS, though
          key: ${{ runner.os }}-${{ runner.arch }}-${{ env.cargo_env_version }}
